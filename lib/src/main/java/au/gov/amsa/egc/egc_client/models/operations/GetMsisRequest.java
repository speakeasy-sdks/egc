/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package au.gov.amsa.egc.egc_client.models.operations;

import au.gov.amsa.egc.egc_client.utils.SpeakeasyMetadata;
import java.time.OffsetDateTime;


public class GetMsisRequest {
    /**
     * the type of broadcast
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=broadcastType")
    public au.gov.amsa.egc.egc_client.models.shared.BroadcastType broadcastType;

    public GetMsisRequest withBroadcastType(au.gov.amsa.egc.egc_client.models.shared.BroadcastType broadcastType) {
        this.broadcastType = broadcastType;
        return this;
    }
    
    /**
     * Describes to the server the starting point of 
     * the next page of results and is obtained from 
     * the current page. May contain an offset if desired
     * but is at the discretion of implementer. Note that
     * it is possible that a call specifying a continuation
     * token may return en empty list (but an empty list return 
     * should not have a continuation token on it so at 
     * that point paging would stop).
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=continuationToken")
    public String continuationToken;

    public GetMsisRequest withContinuationToken(String continuationToken) {
        this.continuationToken = continuationToken;
        return this;
    }
    
    /**
     * If endTimeMaxInclusive is true (the default value if not specified)
     * then filters MSIs on endTime &lt;= endTimeMax.
     * 
     * If endTimeMaxInclusive is false then filters MSIs
     * on endTime &lt; endTimeMax.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=endTimeMax")
    public OffsetDateTime endTimeMax;

    public GetMsisRequest withEndTimeMax(OffsetDateTime endTimeMax) {
        this.endTimeMax = endTimeMax;
        return this;
    }
    
    /**
     * If endTimeMaxInclusive is true (the default value if not specified)
     * then filters MSIs on endTime &lt;= endTimeMax.
     * 
     * If endTimeMaxInclusive is false then filters MSIs
     * on endTime &lt; endTimeMax.
     * 
     * If endTimeMaxInclusive not specified then has no effect.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=endTimeMaxInclusive")
    public Boolean endTimeMaxInclusive;

    public GetMsisRequest withEndTimeMaxInclusive(Boolean endTimeMaxInclusive) {
        this.endTimeMaxInclusive = endTimeMaxInclusive;
        return this;
    }
    
    /**
     * If endTimeMinInclusive is true (the default value if not specified)
     * then filters MSIs on startTime &gt;= startTimeMin.
     * 
     * If startTimeMinInclusive is false then filters MSIs
     * on startTime &gt; startTimeMin.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=endTimeMin")
    public OffsetDateTime endTimeMin;

    public GetMsisRequest withEndTimeMin(OffsetDateTime endTimeMin) {
        this.endTimeMin = endTimeMin;
        return this;
    }
    
    /**
     * If endTimeMinInclusive is true (the default value if not specified)
     * then filters MSIs on endTime &gt;= endTimeMin.
     * 
     * If endTimeMinInclusive is false then filters MSIs
     * on endTime &gt; endTimeMin.
     * 
     * If endTimeMinInclusive not specified then has no effect.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=endTimeMinInclusive")
    public Boolean endTimeMinInclusive;

    public GetMsisRequest withEndTimeMinInclusive(Boolean endTimeMinInclusive) {
        this.endTimeMinInclusive = endTimeMinInclusive;
        return this;
    }
    
    /**
     * Requests that at most `limit` MSIs are returned in the call.
     * The server may cap the requested `limit` (fewer items may be
     * returned). To request the next page available include the 
     * returned `continuationToken` in the next call. If there are 
     * no more items available then the response will not contain
     * a `continuationToken`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=limit")
    public Integer limit;

    public GetMsisRequest withLimit(Integer limit) {
        this.limit = limit;
        return this;
    }
    
    /**
     * If startTimeMaxInclusive is true (the default value if not specified)
     * then filters MSIs on startTime &lt;= startTimeMax.
     * 
     * If startTimeMaxInclusive is false then filters MSIs
     * on startTime &lt; startTimeMax.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=startTimeMax")
    public OffsetDateTime startTimeMax;

    public GetMsisRequest withStartTimeMax(OffsetDateTime startTimeMax) {
        this.startTimeMax = startTimeMax;
        return this;
    }
    
    /**
     * If startTimeMaxInclusive is true (the default value if not specified)
     * then filters MSIs on startTime &lt;= startTimeMax.
     * 
     * If startTimeMaxInclusive is false then filters MSIs
     * on startTime &lt; startTimeMax.
     * 
     * If startTimeMaxInclusive not specified then has no effect.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=startTimeMaxInclusive")
    public Boolean startTimeMaxInclusive;

    public GetMsisRequest withStartTimeMaxInclusive(Boolean startTimeMaxInclusive) {
        this.startTimeMaxInclusive = startTimeMaxInclusive;
        return this;
    }
    
    /**
     * If startTimeMinInclusive is true (the default value if not specified)
     * then filters MSIs on startTime &gt;= startTimeMin.
     * 
     * If startTimeMinInclusive is false then filters MSIs
     * on startTime &gt; startTimeMin.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=startTimeMin")
    public OffsetDateTime startTimeMin;

    public GetMsisRequest withStartTimeMin(OffsetDateTime startTimeMin) {
        this.startTimeMin = startTimeMin;
        return this;
    }
    
    /**
     * If startTimeMinInclusive is true (the default value if not specified)
     * then filters MSIs on startTime &gt;= startTimeMin.
     * 
     * If startTimeMinInclusive is false then filters MSIs
     * on startTime &gt; startTimeMin.
     * 
     * If startTimeMinInclusive not specified then has no effect.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=startTimeMinInclusive")
    public Boolean startTimeMinInclusive;

    public GetMsisRequest withStartTimeMinInclusive(Boolean startTimeMinInclusive) {
        this.startTimeMinInclusive = startTimeMinInclusive;
        return this;
    }
    
    /**
     * Only MSIs that have a status in the given list
     * are returned. If the list is empty (or the parameter
     * is not present) then no filtering on status occurs.
     * **TODO** support multi-status filtering or just one?
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=status")
    public au.gov.amsa.egc.egc_client.models.shared.Status[] status;

    public GetMsisRequest withStatus(au.gov.amsa.egc.egc_client.models.shared.Status[] status) {
        this.status = status;
        return this;
    }
    
    public GetMsisRequest(){}
}
